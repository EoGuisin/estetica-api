// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// ----------------------------------------
// Core Models
// ----------------------------------------

enum ClinicStatus {
  PENDING_PAYMENT
  ACTIVE
  INACTIVE
  CANCELED
}

enum RoleType {
  ADMIN
  PROFESSIONAL
  SECRETARY
  FINANCIAL
  COMMERCIAL
}

enum CommissionTriggerEvent {
  ON_SALE // Comissão gerada imediatamente na venda (TreatmentPlan criado)
  ON_FIRST_INSTALLMENT_PAID // Comissão gerada quando a primeira parcela é paga (total ou parcialmente)
  ON_FULL_PLAN_PAID // Comissão gerada apenas quando todas as parcelas do plano estão quitadas
  ON_EACH_INSTALLMENT_PAID // Comissão gerada proporcionalmente a cada parcela quitada
}

model Account {
  id           String        @id @default(uuid())
  ownerId      String        @unique
  owner        User          @relation("AccountOwner", fields: [ownerId], references: [id])
  clinics      Clinic[]
  subscription Subscription?

  stripeCustomerId String? @unique

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("accounts")
}

model SubscriptionPlan {
  id   String @id @default(uuid())
  name String @unique // "Essencial Mensal", "Experts Anual"

  // Integração Stripe
  stripeProductId String? // ID do Produto no Stripe
  stripePriceId   String? // ID do Preço no Stripe

  // Limites Base do Plano
  maxUsers   Int    @default(1)
  maxStorage BigInt @default(0) // Em Bytes (10GB = 10737418240)

  // Funcionalidades (Feature Flags)
  hasCrm    Boolean @default(false)
  hasAi     Boolean @default(false)
  hasApp    Boolean @default(false)
  hasFunnel Boolean @default(false)
  hasWhats  Boolean @default(false)

  price    Decimal @db.Decimal(10, 2)
  isActive Boolean @default(true)

  subscriptions Subscription[]

  @@map("subscription_plans")
}

// A assinatura ATIVA de uma conta
model Subscription {
  id        String @id @default(uuid())
  accountId String @unique
  planId    String

  // Status do Stripe
  stripeSubscriptionId String?  @unique
  status               String // "active", "past_due", "canceled", "incomplete"
  currentPeriodStart   DateTime
  currentPeriodEnd     DateTime

  // Limites ATIVOS (Plano Base + Adicionais comprados)
  // Isso facilita a verificação na API sem ter que somar tabelas de adicionais toda vez
  currentMaxUsers   Int
  currentMaxStorage BigInt

  // Features ATIVAS (Plano Base + Adicionais)
  activeCrm    Boolean @default(false)
  activeAi     Boolean @default(false)
  activeApp    Boolean @default(false)
  activeFunnel Boolean @default(false)
  activeWhats  Boolean @default(false)

  account Account          @relation(fields: [accountId], references: [id], onDelete: Cascade)
  plan    SubscriptionPlan @relation(fields: [planId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("subscriptions")
}

model Clinic {
  id          String       @id @default(uuid())
  name        String
  taxId       String       @unique
  status      ClinicStatus @default(PENDING_PAYMENT)
  addressId   String?
  accountId   String
  storageUsed BigInt       @default(0)

  allowParallelAppointments Boolean @default(false)
  parallelAppointmentsLimit Int     @default(1)
  openingHour               String  @default("08:00")
  closingHour               String  @default("18:00")

  // --- CORREÇÃO AQUI: APENAS A RELAÇÃO N:N ---
  users User[] @relation("UserClinics")
  // REMOVA: userId e a relação antiga user

  account Account  @relation(fields: [accountId], references: [id], onDelete: Cascade)
  address Address? @relation(fields: [addressId], references: [id])

  // Outras relações existentes...
  patients             Patient[]
  treatmentPlans       TreatmentPlan[]
  anamnesisTemplates   AnamnesisTemplate[]
  patientAssessments   PatientAssessment[]
  CommissionPlan       CommissionPlan[]
  ProductCategory      ProductCategory[]
  ProductBrand         ProductBrand[]
  Supplier             Supplier[]
  Product              Product[]
  paymentInstallments  PaymentInstallment[]
  expenseCategories    ExpenseCategory[]
  expenses             Expense[]
  commissionRecords    CommissionRecord[]
  BankAccount          BankAccount[]
  FinancialTransaction FinancialTransaction[]
  CashRegisterSession  CashRegisterSession[]
  roles                Role[]
  professionalCouncils ProfessionalCouncil[]
  specialties          Specialty[]
  trafficSources       TrafficSource[]
  appointmentTypes     AppointmentType[]
  procedures           Procedure[]
  specialtyTemplates   SpecialtyTemplate[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("clinics")
}

model PasswordResetToken {
  id        String   @id @default(uuid())
  token     String   @unique
  expiresAt DateTime
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@map("password_reset_tokens")
}

model User {
  id                  String  @id @default(uuid())
  isProfessional      Boolean @default(false)
  fullName            String
  cpf                 String? @unique
  email               String  @unique
  phone               String?
  passwordHash        String
  electronicSignature String?
  scheduleStartHour   String?
  scheduleEndHour     String?
  appointmentDuration Int?
  notes               String?
  color               String? @default("#ffffff")

  // Relações
  roleId String?
  role   Role?   @relation(fields: [roleId], references: [id])

  commissionPlanId String?
  CommissionPlan   CommissionPlan? @relation(fields: [commissionPlanId], references: [id])

  professionalCouncilId String?
  ProfessionalCouncil   ProfessionalCouncil? @relation(fields: [professionalCouncilId], references: [id])

  professionalCouncilRegistry String?
  signatureImagePath          String?
  workingDays                 String[] @default([])

  // --- CORREÇÃO AQUI: APENAS A RELAÇÃO N:N ---
  clinics Clinic[] @relation("UserClinics")
  // REMOVA: clinicId e a relação antiga clinic

  // Outras relações existentes...
  ownedAccount        Account?              @relation("AccountOwner")
  specialties         Specialty[]           @relation("ProfessionalSpecialties")
  appointments        Appointment[]
  sales               TreatmentPlan[]
  assessments         PatientAssessment[]
  medicalReports      MedicalReport[]
  prescriptions       Prescription[]
  openedCashSessions  CashRegisterSession[] @relation("OpenedByUser")
  closedCashSessions  CashRegisterSession[] @relation("ClosedByUser")
  commissions         CommissionRecord[]
  patientDocuments    PatientDocument[]
  passwordResetTokens PasswordResetToken[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("users")
}

model CommissionPlan {
  id          String  @id @default(uuid())
  name        String
  description String?
  clinicId    String
  isActive    Boolean @default(true)

  // --- NOVO CAMPO ADICIONADO ---
  triggerEvent CommissionTriggerEvent @default(ON_FULL_PLAN_PAID) // Define um padrão

  clinic Clinic           @relation(fields: [clinicId], references: [id])
  tiers  CommissionTier[]
  users  User[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("commission_plans")
}

model ProfessionalCouncil {
  id          String  @id @default(uuid())
  name        String
  description String?

  clinicId String?
  clinic   Clinic? @relation(fields: [clinicId], references: [id])

  users User[]

  @@unique([name, clinicId])
  @@map("professional_councils")
}

model ProductCategory {
  id          String    @id @default(uuid())
  name        String    @unique
  description String?
  clinicId    String
  clinic      Clinic    @relation(fields: [clinicId], references: [id])
  products    Product[]

  @@unique([name, clinicId])
  @@map("product_categories")
}

// Modelo para as Marcas dos Produtos
model ProductBrand {
  id          String  @id @default(uuid())
  name        String
  description String?
  clinicId    String

  clinic   Clinic    @relation(fields: [clinicId], references: [id])
  products Product[]

  @@unique([name, clinicId])
  @@map("product_brands")
}

// Modelo para os Fornecedores
model Supplier {
  id          String  @id @default(uuid())
  name        String
  description String?
  clinicId    String

  clinic         Clinic          @relation(fields: [clinicId], references: [id])
  stockMovements StockMovement[]
  Expense        Expense[]

  @@unique([name, clinicId])
  @@map("suppliers")
}

model Product {
  id          String  @id @default(uuid())
  name        String
  description String?
  sku         String? @unique // Código de barras ou SKU para identificação única

  // Relacionamentos com os catálogos
  categoryId String
  brandId    String
  clinicId   String

  category ProductCategory @relation(fields: [categoryId], references: [id])
  brand    ProductBrand    @relation(fields: [brandId], references: [id])
  clinic   Clinic          @relation(fields: [clinicId], references: [id])

  // Controle de Estoque
  currentStock      Int  @default(0) // Quantidade atual em estoque
  lowStockThreshold Int? @default(0) // Limite para alerta de estoque baixo

  stockMovements StockMovement[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([sku, clinicId])
  @@map("products")
}

enum StockMovementType {
  ENTRY // Entrada de produto (compra)
  EXIT // Saída de produto (uso em procedimento, venda, perda)
}

model StockMovement {
  id            String            @id @default(uuid())
  type          StockMovementType // Se é ENTRADA ou SAÍDA
  quantity      Int // Quantidade de itens na movimentação
  date          DateTime // Data em que a movimentação ocorreu
  totalValue    Decimal?          @db.Decimal(10, 2) // Valor total (geralmente para entradas)
  invoiceNumber String? // Número da nota fiscal (geralmente para entradas)
  notes         String? // Observações
  expiryDate    DateTime?

  productId String
  product   Product @relation(fields: [productId], references: [id])

  supplierId String?
  supplier   Supplier? @relation(fields: [supplierId], references: [id])

  appointmentId String?
  appointment   Appointment? @relation(fields: [appointmentId], references: [id])

  createdAt DateTime @default(now())

  @@map("stock_movements")
}

model CommissionTier {
  id               String   @id @default(uuid())
  commissionPlanId String
  minThreshold     Decimal  @db.Decimal(10, 2) // Valor mínimo de faturamento para esta faixa
  maxThreshold     Decimal? @db.Decimal(10, 2) // Valor máximo. Nulo significa "acima do mínimo"
  percentage       Decimal  @db.Decimal(5, 2) // A porcentagem de comissão

  commissionPlan CommissionPlan @relation(fields: [commissionPlanId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("commission_tiers")
}

model Patient {
  id              String         @id @default(uuid())
  imageUrl        String?
  cpf             String
  name            String
  email           String?
  socialName      String?
  birthDate       DateTime
  identityCard    String?
  gender          String?
  maritalStatus   String?
  ethnicity       String?
  motherName      String?
  occupation      String?
  notes           String?
  clinicId        String
  trafficSourceId String?
  trafficSource   TrafficSource? @relation(fields: [trafficSourceId], references: [id])

  // Guardian Info
  guardianName      String?
  guardianBirthDate DateTime?

  clinic            Clinic              @relation(fields: [clinicId], references: [id])
  address           Address?            @relation(fields: [addressId], references: [id])
  addressId         String?
  phones            Phone[]
  treatmentPlans    TreatmentPlan[]
  appointments      Appointment[]
  assessments       PatientAssessment[]
  attachments       Attachment[]
  beforeAfterImages BeforeAfterImage[]

  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  PatientDocument PatientDocument[]
  MedicalReport   MedicalReport[]
  Prescription    Prescription[]

  @@unique([cpf, clinicId])
  @@map("patients")
}

model TrafficSource {
  id   String @id @default(uuid())
  name String

  clinicId String?
  clinic   Clinic? @relation(fields: [clinicId], references: [id])

  patients Patient[]

  @@unique([name, clinicId])
  @@map("traffic_sources")
}

// ----------------------------------------
// Relation and Catalog Models
// ----------------------------------------

model Address {
  id           String  @id @default(uuid())
  zipCode      String
  state        String
  city         String
  neighborhood String
  street       String
  number       String
  complement   String?

  patients Patient[]
  clinics  Clinic[]

  @@map("addresses")
}

model Phone {
  id         String  @id @default(uuid())
  number     String
  isWhatsapp Boolean @default(false)
  patientId  String

  patient Patient @relation(fields: [patientId], references: [id], onDelete: Cascade)

  @@map("phones")
}

model Role {
  id           String   @id @default(uuid())
  name         String
  type         RoleType @default(ADMIN)
  description  String?
  isSuperAdmin Boolean  @default(false)

  clinicId String?
  clinic   Clinic? @relation(fields: [clinicId], references: [id])

  users User[]

  @@unique([name, clinicId])
  @@map("roles")
}

model Specialty {
  id   String @id @default(uuid())
  name String

  clinicId String?
  clinic   Clinic? @relation(fields: [clinicId], references: [id])

  procedures    Procedure[]
  professionals User[]              @relation("ProfessionalSpecialties")
  templates     SpecialtyTemplate[]

  @@unique([name, clinicId])
  @@map("specialties")
}

model Procedure {
  id            String  @id @default(uuid())
  name          String
  standardPrice Decimal @db.Decimal(10, 2)
  description   String?

  specialtyId String
  specialty   Specialty @relation(fields: [specialtyId], references: [id])

  clinicId String?
  clinic   Clinic? @relation(fields: [clinicId], references: [id])

  treatmentPlans TreatmentPlanProcedure[]

  @@map("procedures")
}

enum TreatmentPlanStatus {
  DRAFT // Orçamento/Simulação
  APPROVED // Venda Efetivada
  CANCELED // Cancelado
}

model TreatmentPlan {
  id                 String   @id @default(uuid())
  patientId          String
  clinicId           String
  sellerId           String
  subtotal           Decimal  @db.Decimal(10, 2)
  discountAmount     Decimal? @db.Decimal(10, 2)
  discountPercentage Decimal? @db.Decimal(5, 2)
  surcharge          Decimal? @db.Decimal(10, 2)
  total              Decimal  @db.Decimal(10, 2)
  installmentCount   Int?     @default(1)

  status              TreatmentPlanStatus      @default(APPROVED) // Default APPROVED para manter compatibilidade
  patient             Patient                  @relation(fields: [patientId], references: [id], onDelete: Cascade)
  clinic              Clinic                   @relation(fields: [clinicId], references: [id])
  seller              User                     @relation(fields: [sellerId], references: [id])
  procedures          TreatmentPlanProcedure[]
  appointments        Appointment[]
  beforeAfterImages   BeforeAfterImage[]
  paymentInstallments PaymentInstallment[]
  commissionRecords   CommissionRecord[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("treatment_plans")
}

model TreatmentPlanProcedure {
  id                 String  @id @default(uuid())
  treatmentPlanId    String
  procedureId        String
  contractedSessions Int
  completedSessions  Int     @default(0)
  unitPrice          Decimal @db.Decimal(10, 2)
  followUps          Int     @default(0)

  treatmentPlan TreatmentPlan @relation(fields: [treatmentPlanId], references: [id], onDelete: Cascade)
  procedure     Procedure     @relation(fields: [procedureId], references: [id])
  appointments  Appointment[]

  @@map("treatment_plan_procedures")
}

model Appointment {
  id        String   @id @default(uuid())
  date      DateTime
  startTime String // "14:30"
  endTime   String // "15:30"
  notes     String?
  status    String   @default("SCHEDULED") // SCHEDULED, CONFIRMED, CANCELED, COMPLETED

  patientId                String
  professionalId           String
  appointmentTypeId        String
  treatmentPlanId          String? // Optional, if it's a session from a plan
  treatmentPlanProcedureId String?

  patient                Patient                 @relation(fields: [patientId], references: [id], onDelete: Cascade)
  professional           User                    @relation(fields: [professionalId], references: [id])
  appointmentType        AppointmentType         @relation(fields: [appointmentTypeId], references: [id])
  treatmentPlan          TreatmentPlan?          @relation(fields: [treatmentPlanId], references: [id])
  assessment             PatientAssessment?
  clinicalRecord         ClinicalRecord?
  StockMovement          StockMovement[]
  treatmentPlanProcedure TreatmentPlanProcedure? @relation(fields: [treatmentPlanProcedureId], references: [id])
  createdAt              DateTime                @default(now())
  updatedAt              DateTime                @updatedAt

  @@map("appointments")
}

model AppointmentType {
  id   String @id @default(uuid())
  name String

  clinicId String?
  clinic   Clinic? @relation(fields: [clinicId], references: [id])

  appointments Appointment[]

  @@unique([name, clinicId])
  @@map("appointment_types")
}

enum QuestionType {
  YES_NO
  SHORT_TEXT
  LONG_TEXT
  SINGLE_SELECT
  MULTIPLE_SELECT
  SCALE // 1-10 scale
  DATE
}

model AnamnesisTemplate {
  id          String  @id @default(uuid())
  name        String
  description String?
  clinicId    String
  isActive    Boolean @default(true)

  clinic      Clinic              @relation(fields: [clinicId], references: [id])
  sections    AnamnesisSection[]
  assessments PatientAssessment[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("anamnesis_templates")
}

model AnamnesisSection {
  id         String @id @default(uuid())
  templateId String
  title      String
  order      Int

  template  AnamnesisTemplate   @relation(fields: [templateId], references: [id], onDelete: Cascade)
  questions AnamnesisQuestion[]

  @@map("anamnesis_sections")
}

model AnamnesisQuestion {
  id               String       @id @default(uuid())
  sectionId        String
  question         String
  description      String?
  type             QuestionType
  isRequired       Boolean      @default(false)
  order            Int
  options          Json? // For select/checkbox options
  parentQuestionId String? // For sub-questions
  showCondition    Json? // Conditions to show this question

  section        AnamnesisSection     @relation(fields: [sectionId], references: [id], onDelete: Cascade)
  parentQuestion AnamnesisQuestion?   @relation("SubQuestions", fields: [parentQuestionId], references: [id])
  subQuestions   AnamnesisQuestion[]  @relation("SubQuestions")
  responses      AssessmentResponse[]

  @@map("anamnesis_questions")
}

model PatientAssessment {
  id             String  @id @default(uuid())
  patientId      String
  appointmentId  String? @unique
  templateId     String
  professionalId String
  clinicId       String
  status         String  @default("IN_PROGRESS") // IN_PROGRESS, COMPLETED

  patient      Patient              @relation(fields: [patientId], references: [id], onDelete: Cascade)
  appointment  Appointment?         @relation(fields: [appointmentId], references: [id])
  template     AnamnesisTemplate    @relation(fields: [templateId], references: [id])
  professional User                 @relation(fields: [professionalId], references: [id])
  clinic       Clinic               @relation(fields: [clinicId], references: [id])
  responses    AssessmentResponse[]

  completedAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([patientId])
  @@index([appointmentId])
  @@map("patient_assessments")
}

model AssessmentResponse {
  id           String @id @default(uuid())
  assessmentId String
  questionId   String
  value        Json // Flexible storage for different response types

  assessment PatientAssessment @relation(fields: [assessmentId], references: [id], onDelete: Cascade)
  question   AnamnesisQuestion @relation(fields: [questionId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([assessmentId, questionId])
  @@map("assessment_responses")
}

model ClinicalRecord {
  id            String  @id @default(uuid())
  appointmentId String  @unique
  diagnosis     String? @db.Text

  appointment Appointment @relation(fields: [appointmentId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("clinical_records")
}

model Attachment {
  id          String  @id @default(uuid())
  patientId   String
  fileName    String
  description String?
  filePath    String // Path in Supabase storage
  fileType    String // e.g., 'image/png', 'application/pdf'
  size        Int // in bytes

  patient Patient @relation(fields: [patientId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@map("attachments")
}

model BeforeAfterImage {
  id              String  @id @default(uuid())
  patientId       String
  treatmentPlanId String? // Link to a specific treatment
  description     String?
  beforeImagePath String
  afterImagePath  String?

  patient       Patient        @relation(fields: [patientId], references: [id], onDelete: Cascade)
  treatmentPlan TreatmentPlan? @relation(fields: [treatmentPlanId], references: [id])

  createdAt DateTime @default(now())

  @@map("before_after_images")
}

enum DocumentType {
  TERM // Termo de Consentimento, LGPD, etc.
  CONTRACT // Contrato de Prestação de Serviço
}

enum DocumentStatus {
  PENDING // Aguardando assinatura
  SIGNED // Assinado
  CANCELED // Cancelado
}

model PatientDocument {
  id                   String         @id @default(uuid())
  patientId            String
  templateId           String? // Link to the template used
  fileName             String
  description          String?
  filePath             String
  fileType             String
  size                 Int
  type                 DocumentType
  status               DocumentStatus @default(PENDING)
  patientSignaturePath String?
  signedAt             DateTime?
  signatureToken       String?        @default(uuid())

  professionalId String?
  professional   User?   @relation(fields: [professionalId], references: [id])

  patient  Patient            @relation(fields: [patientId], references: [id], onDelete: Cascade)
  template SpecialtyTemplate? @relation(fields: [templateId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("patient_documents")
}

model SpecialtyTemplate {
  id          String       @id @default(uuid())
  specialtyId String
  name        String // "Termo Padrão Botox"
  content     String       @db.Text
  type        DocumentType // TERM or CONTRACT
  isActive    Boolean      @default(true)

  clinicId String
  clinic   Clinic @relation(fields: [clinicId], references: [id])

  specialty        Specialty         @relation(fields: [specialtyId], references: [id], onDelete: Cascade)
  patientDocuments PatientDocument[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("specialty_templates")
}

model MedicalReport {
  id             String @id @default(uuid())
  content        String @db.Text
  patientId      String
  professionalId String

  patient      Patient @relation(fields: [patientId], references: [id], onDelete: Cascade)
  professional User    @relation(fields: [professionalId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("medical_reports")
}

model Prescription {
  id             String @id @default(uuid())
  content        String @db.Text
  patientId      String
  professionalId String

  patient      Patient @relation(fields: [patientId], references: [id], onDelete: Cascade)
  professional User    @relation(fields: [professionalId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("prescriptions")
}

// ----------------------------------------
// Financial Models
// ----------------------------------------

enum PaymentStatus {
  PENDING // Parcela aguardando pagamento
  PAID // Parcela paga
  OVERDUE // Parcela vencida e não paga
  CANCELED // Parcela cancelada (ex: plano cancelado)
}

enum PaymentMethod {
  CREDIT_CARD
  DEBIT_CARD
  BANK_TRANSFER // PIX, TED, DOC
  CASH
  CHECK // Cheque
  OTHER
}

// Representa cada parcela individual de um TreatmentPlan
model PaymentInstallment {
  id                String         @id @default(uuid())
  treatmentPlanId   String
  installmentNumber Int // Número da parcela (1, 2, 3...)
  dueDate           DateTime // Data de vencimento da parcela
  amountDue         Decimal        @db.Decimal(10, 2) // Valor desta parcela
  status            PaymentStatus  @default(PENDING)
  paidAmount        Decimal?       @db.Decimal(10, 2) // Valor efetivamente pago (pode ser parcial)
  paymentDate       DateTime? // Data em que o pagamento foi recebido
  paymentMethod     PaymentMethod? // Como foi pago
  notes             String? // Observações sobre o pagamento
  clinicId          String // Para garantir o escopo

  treatmentPlan TreatmentPlan @relation(fields: [treatmentPlanId], references: [id], onDelete: Cascade)
  clinic        Clinic        @relation(fields: [clinicId], references: [id])

  createdAt            DateTime               @default(now())
  updatedAt            DateTime               @updatedAt
  CommissionRecord     CommissionRecord[]
  FinancialTransaction FinancialTransaction[]

  @@index([treatmentPlanId])
  @@index([status])
  @@index([dueDate])
  @@index([clinicId])
  @@map("payment_installments")
}

// Categoria para Despesas (Contas a Pagar)
model ExpenseCategory {
  id       String    @id @default(uuid())
  name     String
  clinicId String
  clinic   Clinic    @relation(fields: [clinicId], references: [id])
  expenses Expense[]

  @@unique([name, clinicId])
  @@map("expense_categories")
}

// Representa as Contas a Pagar da clínica
model Expense {
  id          String        @id @default(uuid())
  clinicId    String
  description String // Ex: Aluguel Outubro, Compra Botox Rennova NF 123
  amount      Decimal       @db.Decimal(10, 2) // Valor da despesa
  dueDate     DateTime // Vencimento
  paymentDate DateTime? // Data do pagamento
  status      PaymentStatus @default(PENDING) // PENDING, PAID, OVERDUE
  supplierId  String? // Opcional: Link para o fornecedor
  categoryId  String? // Opcional: Categoria da despesa
  notes       String?

  clinic   Clinic           @relation(fields: [clinicId], references: [id])
  supplier Supplier?        @relation(fields: [supplierId], references: [id])
  category ExpenseCategory? @relation(fields: [categoryId], references: [id])

  createdAt            DateTime               @default(now())
  updatedAt            DateTime               @updatedAt
  FinancialTransaction FinancialTransaction[]

  @@index([clinicId])
  @@index([status])
  @@index([dueDate])
  @@map("expenses")
}

enum CommissionStatus {
  PENDING // Comissão calculada, aguardando pagamento ao profissional
  PAID // Comissão paga ao profissional
  CANCELED // Comissão cancelada (ex: venda desfeita)
}

// Registra as comissões calculadas para cada profissional
model CommissionRecord {
  id                   String           @id @default(uuid())
  clinicId             String
  professionalId       String // Profissional que receberá
  treatmentPlanId      String // Venda que originou a comissão
  paymentInstallmentId String? // Parcela que 'liberou' esta comissão (opcional, depende da regra)
  calculatedAmount     Decimal          @db.Decimal(10, 2) // Valor da comissão
  calculationDate      DateTime         @default(now()) // Quando foi calculada
  status               CommissionStatus @default(PENDING)
  paymentDate          DateTime? // Quando a clínica pagou ao profissional

  clinic             Clinic              @relation(fields: [clinicId], references: [id])
  professional       User                @relation(fields: [professionalId], references: [id])
  treatmentPlan      TreatmentPlan       @relation(fields: [treatmentPlanId], references: [id])
  paymentInstallment PaymentInstallment? @relation(fields: [paymentInstallmentId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([clinicId])
  @@index([professionalId])
  @@index([status])
  @@map("commission_records")
}

model BankAccount {
  id      String  @id @default(uuid())
  name    String // Ex: "Caixa Matriz", "Conta Itaú"
  balance Decimal @default(0.0) @db.Decimal(10, 2) // Saldo atual

  clinicId String
  clinic   Clinic @relation(fields: [clinicId], references: [id])

  // Transações que saíram desta conta
  transactionsFrom     FinancialTransaction[] @relation("TransactionFrom")
  // Transações que entraram nesta conta (para transferências)
  transactionsTo       FinancialTransaction[] @relation("TransactionTo")
  cashRegisterSessions CashRegisterSession[]
  createdAt            DateTime               @default(now())
  updatedAt            DateTime               @updatedAt

  @@unique([name, clinicId])
  @@map("bank_accounts")
}

enum TransactionType {
  REVENUE // Entrada (Recebimento de Parcela)
  EXPENSE // Saída (Pagamento de Despesa)
  TRANSFER // Transferência entre contas
}

enum CashRegisterSessionStatus {
  OPEN
  CLOSED
}

// NOVO MODELO: Para gerenciar Abertura e Fechamento de Caixa
model CashRegisterSession {
  id              String   @id @default(uuid())
  clinicId        String
  bankAccountId   String // Qual conta/caixa está sendo aberta (Ex: "Caixa Matriz")
  openedByUserId  String // Quem abriu
  openedAt        DateTime @default(now())
  openingBalance  Decimal  @db.Decimal(10, 2) // Saldo que o SISTEMA registrou na abertura
  observedOpening Decimal  @db.Decimal(10, 2) // Saldo que o USUÁRIO contou na abertura

  closedByUserId  String? // Quem fechou
  closedAt        DateTime?
  closingBalance  Decimal?  @db.Decimal(10, 2) // Saldo que o SISTEMA registrou no fechamento
  observedClosing Decimal?  @db.Decimal(10, 2) // Saldo que o USUÁRIO contou no fechamento

  // Diferença entre o saldo do sistema e o que o usuário contou
  discrepancy Decimal? @db.Decimal(10, 2)

  status CashRegisterSessionStatus @default(OPEN)
  notes  String?

  clinic       Clinic      @relation(fields: [clinicId], references: [id])
  bankAccount  BankAccount @relation(fields: [bankAccountId], references: [id])
  openedByUser User        @relation("OpenedByUser", fields: [openedByUserId], references: [id])
  closedByUser User?       @relation("ClosedByUser", fields: [closedByUserId], references: [id])

  // Todas as transações que ocorreram DENTRO desta sessão
  transactions FinancialTransaction[]

  @@index([clinicId, status])
  @@index([bankAccountId, status])
  @@map("cash_register_sessions")
}

// O "Livro Caixa" / O verdadeiro "Fluxo de Caixa"
model FinancialTransaction {
  id          String          @id @default(uuid())
  clinicId    String
  description String
  amount      Decimal         @db.Decimal(10, 2) // Valor da transação
  type        TransactionType
  date        DateTime // Data que a transação ocorreu (data do pagamento)

  // Relacionamentos
  bankAccountId String // De qual conta saiu (ou entrou, se REVENUE)
  bankAccount   BankAccount @relation("TransactionFrom", fields: [bankAccountId], references: [id])

  // Opcional: Para transferências
  targetBankAccountId String?
  targetBankAccount   BankAccount? @relation("TransactionTo", fields: [targetBankAccountId], references: [id])

  // Opcional: Linkar com a origem
  paymentInstallmentId String?
  paymentInstallment   PaymentInstallment? @relation(fields: [paymentInstallmentId], references: [id], onDelete: SetNull)

  expenseId String?
  expense   Expense? @relation(fields: [expenseId], references: [id], onDelete: SetNull)

  clinic    Clinic   @relation(fields: [clinicId], references: [id])
  createdAt DateTime @default(now())

  // --- LINHA ADICIONADA ---
  // Vincula esta transação à sessão de caixa que estava aberta
  cashRegisterSessionId String?
  cashRegisterSession   CashRegisterSession? @relation(fields: [cashRegisterSessionId], references: [id], onDelete: SetNull)
  // -------------------------

  @@index([clinicId, date])
  @@map("financial_transactions")
}
